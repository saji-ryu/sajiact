/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sajiact_core_1 = __webpack_require__(/*! sajiact-core */ \"../sajiact/dist/index.js\");\nconsole.log('h test', sajiact_core_1.h('div', null, 'hello'));\nconst TestFC = (props) => {\n    return sajiact_core_1.h('div', null, [\n        sajiact_core_1.h('button', { onclick: props.onclick }, 'hello'),\n        sajiact_core_1.h('button', { onclick: props.onclick }, 'hello'),\n    ]);\n};\n// @ts-ignore\nclass TestCC extends sajiact_core_1.Component {\n    constructor() {\n        super();\n    }\n    componentDidMount() { }\n    componentWillReceiveProps(next) { }\n    render() {\n        return sajiact_core_1.h('div', null, [\n            sajiact_core_1.h('button', { onclick: this.props.onclick }, 'hello'),\n            sajiact_core_1.h('button', { onclick: this.props.onclick }, 'hello'),\n        ]);\n    }\n}\n// @ts-ignore\nsajiact_core_1.render(sajiact_core_1.h(TestFC, { onclick: () => alert('world') }, null), document.getElementById('main'));\n// ------------------------------\n// // @ts-ignore\n// class App extends Component {\n//   constructor() {\n//     super();\n//     this.state = {\n//       count: 10000000,\n//       data: [],\n//     };\n//   }\n//   componentDidMount() {\n//     this.setState({\n//       ...this.state,\n//       count: 0,\n//       data: [\n//         {\n//           name: 'taro',\n//         },\n//         {\n//           name: 'hanako',\n//         },\n//       ],\n//     });\n//   }\n//   componentWillReceiveProps(next) {\n//     console.log('next.props:', next.props);\n//   }\n//   render() {\n//     return h(\n//       'div',\n//       {\n//         style: {\n//           color: 'blue',\n//         },\n//       },\n//       h(\n//         'section',\n//         null,\n//         h('h1', null, 'counting area'),\n//         h('span', null, 'count: '),\n//         h('span', null, this.state.count),\n//         h(\n//           'button',\n//           {\n//             onClick: () =>\n//               this.setState({ ...this.state, count: this.state.count + 1 }),\n//           },\n//           'add'\n//         )\n//       ),\n//       h(\n//         'section',\n//         null,\n//         h('h1', null, 'user data area'),\n//         h(\n//           'ul',\n//           null,\n//           this.state.data.map((d, i) =>\n//             h(ListItem, {\n//               name: d.name,\n//               handleDelete: () => {\n//                 this.setState({\n//                   ...this.state,\n//                   data: this.state.data.filter((_, j) => {\n//                     return i !== j;\n//                   }),\n//                 });\n//               },\n//             })\n//           )\n//         ),\n//         h(\n//           'form',\n//           {\n//             onSubmit: (e) => {\n//               e.preventDefault();\n//               const userName = e.target['name'].value;\n//               this.setState({\n//                 ...this.state,\n//                 data: [\n//                   ...this.state.data,\n//                   {\n//                     name: userName,\n//                   },\n//                 ],\n//               });\n//             },\n//           },\n//           h('input', {\n//             name: 'name',\n//           }),\n//           h(\n//             'button',\n//             {\n//               type: 'submit',\n//             },\n//             'add'\n//           )\n//         )\n//       )\n//     );\n//   }\n// }\n// // @ts-ignore\n// class ListItem extends Component {\n//   componentWillReceiveProps(nextProps, prevProps) {\n//     console.log('next.props:', nextProps);\n//     console.log('next.props:', prevProps);\n//   }\n//   render() {\n//     return h(\n//       'li',\n//       null,\n//       h('span', null, this.props.name),\n//       h(\n//         'button',\n//         {\n//           onClick: () => this.props.handleDelete(),\n//         },\n//         'delete'\n//       )\n//     );\n//   }\n// }\n// // @ts-ignore\n// render(h(App, null, null), document.body);\n\n\n//# sourceURL=webpack://sajiact-example/./src/index.ts?");

/***/ }),

/***/ "../sajiact/dist/component.js":
/*!************************************!*\
  !*** ../sajiact/dist/component.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enqueueRender = exports.getDomSibling = exports.Component = void 0;\nconst index_1 = __webpack_require__(/*! ./diff/index */ \"../sajiact/dist/diff/index.js\");\nconst create_element_1 = __webpack_require__(/*! ./create-element */ \"../sajiact/dist/create-element.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../sajiact/dist/util.js\");\nfunction Component(props) {\n    this.props = props;\n}\nexports.Component = Component;\n/**\n * setState メソッド.\n * component._nextState に次の状態を保存し、enqueueRenderを呼び出して再レンダリングをトリガーする\n */\nComponent.prototype.setState = function (update) {\n    // only clone state when copying to nextState the first time.\n    let s;\n    if (this._nextState != null && this._nextState !== this.state) {\n        s = this._nextState;\n    }\n    else {\n        s = this._nextState = util_1.assign({}, this.state);\n    }\n    if (update) {\n        util_1.assign(s, update);\n    }\n    // Skip update if updater function returned null\n    if (update == null)\n        return;\n    if (this._vnode) {\n        enqueueRender(this);\n    }\n};\n/**\n * render が呼ばれると、Fragment() つまり、props.childrenを返す\n */\nComponent.prototype.render = create_element_1.Fragment;\nfunction getDomSibling(vnode, childIndex) {\n    if (childIndex == null) {\n        // Use childIndex==null as a signal to resume the search from the vnode's sibling\n        return vnode._parent\n            ? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n            : null;\n    }\n    let sibling;\n    for (; childIndex < vnode._children.length; childIndex++) {\n        sibling = vnode._children[childIndex];\n        if (sibling != null && sibling._dom != null) {\n            // Since updateParentDomPointers keeps _dom pointer correct,\n            // we can rely on _dom to tell us if this subtree contains a\n            // rendered DOM node, and what the first rendered DOM node is\n            return sibling._dom;\n        }\n    }\n    // vnodeのchildren からDOMが見つからなかった時の処理\n    return typeof vnode.type == 'function'\n        ? getDomSibling(vnode, undefined)\n        : null;\n}\nexports.getDomSibling = getDomSibling;\n/**\n * 再レンダリングのトリガー, diffを呼び出す\n * @param component rerender したいコンポーネント\n */\nfunction renderComponent(component) {\n    let vnode = component._vnode, oldDom = vnode._dom, parentDom = component._parentDom;\n    if (parentDom) {\n        let commitQueue = [];\n        const oldVNode = util_1.assign({}, vnode);\n        oldVNode._original = oldVNode;\n        let newDom = index_1.diff({\n            parentDom: parentDom,\n            newVNode: vnode,\n            oldVNode: oldVNode,\n            excessDomChildren: null,\n            commitQueue: commitQueue,\n            oldDom: oldDom == null ? getDomSibling(vnode, undefined) : oldDom,\n        });\n        index_1.commitRoot(commitQueue);\n        if (newDom != oldDom) {\n            updateParentDomPointers(vnode);\n        }\n    }\n}\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n    if ((vnode = vnode._parent) != null && vnode._component != null) {\n        vnode._dom = vnode._component.base = null;\n        for (let i = 0; i < vnode._children.length; i++) {\n            let child = vnode._children[i];\n            if (child != null && child._dom != null) {\n                vnode._dom = vnode._component.base = child._dom;\n                break;\n            }\n        }\n        return updateParentDomPointers(vnode);\n    }\n}\n// 差分更新後の副作用を管理するリスト\nlet rerenderQueue = [];\n// callbackの非同期スケジューラー\nconst defer = typeof Promise == 'function'\n    ? Promise.prototype.then.bind(Promise.resolve())\n    : setTimeout;\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\n/**\n * setStateが呼び出すトリガー.\n * データの破壊的操作があるので注意\n * @param c コンポーネント\n */\nfunction enqueueRender(c) {\n    if ((!c._dirty &&\n        (c._dirty = true) &&\n        // queueの操作\n        rerenderQueue.push(c) &&\n        // counterの増加操作\n        !process._rerenderCount++) ||\n        true) {\n        defer(process);\n    }\n}\nexports.enqueueRender = enqueueRender;\n/**\n * renderQueueを実行する\n */\nfunction process() {\n    let queue;\n    while ((process._rerenderCount = rerenderQueue.length)) {\n        queue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n        rerenderQueue = [];\n        // Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n        // process() calls from getting scheduled while `queue` is still being consumed.\n        queue.some((c) => {\n            if (c._dirty)\n                renderComponent(c);\n        });\n    }\n}\nprocess._rerenderCount = 0;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/component.js?");

/***/ }),

/***/ "../sajiact/dist/constants.js":
/*!************************************!*\
  !*** ../sajiact/dist/constants.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IS_NON_DIMENSIONAL = exports.EMPTY_ARR = exports.EMPTY_OBJ = void 0;\nexports.EMPTY_OBJ = {};\nexports.EMPTY_ARR = [];\nexports.IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/constants.js?");

/***/ }),

/***/ "../sajiact/dist/create-element.js":
/*!*****************************************!*\
  !*** ../sajiact/dist/create-element.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Fragment = exports.createVNode = exports.createElement = void 0;\nfunction createElement(type, props, children) {\n    let normalizedProps = {}, key, i;\n    for (i in props) {\n        if (i == 'key')\n            key = props[i];\n        else\n            normalizedProps[i] = props[i];\n    }\n    if (arguments.length > 3) {\n        children = [children];\n        if (!Array.isArray(children)) {\n            throw new Error();\n        }\n        for (i = 3; i < arguments.length; i++) {\n            children.push(arguments[i]);\n        }\n    }\n    if (children != null) {\n        normalizedProps.children = children;\n    }\n    // If a Component VNode, check for and apply defaultProps\n    // Note: type may be undefined in development, must never error here.\n    if (typeof type == 'function' && type.defaultProps != null) {\n        for (i in type.defaultProps) {\n            if (normalizedProps[i] === undefined) {\n                normalizedProps[i] = type.defaultProps[i];\n            }\n        }\n    }\n    // key がなければ undefined のまま入る\n    return createVNode(type, normalizedProps, key, undefined, null);\n}\nexports.createElement = createElement;\nfunction createVNode(type, props, key, ref, original) {\n    // V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n    // Do not inline into createElement and coerceToVNode!\n    const vnode = {\n        type,\n        //@ts-ignore TODO:\n        props,\n        key,\n        ref,\n        _children: null,\n        _parent: null,\n        _depth: 0,\n        _dom: null,\n        // _nextDom must be initialized to undefined b/c it will eventually\n        // be set to dom.nextSibling which can return `null` and it is important\n        // to be able to distinguish between an uninitialized _nextDom and\n        // a _nextDom that has been set to `null`\n        _nextDom: undefined,\n        _component: null,\n        _hydrating: null,\n        constructor: undefined,\n        _original: original,\n    };\n    if (original == null)\n        vnode._original = vnode;\n    return vnode;\n}\nexports.createVNode = createVNode;\nfunction Fragment(props) {\n    return props.children;\n}\nexports.Fragment = Fragment;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/create-element.js?");

/***/ }),

/***/ "../sajiact/dist/diff/children.js":
/*!****************************************!*\
  !*** ../sajiact/dist/diff/children.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.placeChild = exports.diffChildren = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ \"../sajiact/dist/constants.js\");\nconst _1 = __webpack_require__(/*! . */ \"../sajiact/dist/diff/index.js\");\nconst component_1 = __webpack_require__(/*! ../component */ \"../sajiact/dist/component.js\");\nconst create_element_1 = __webpack_require__(/*! ../create-element */ \"../sajiact/dist/create-element.js\");\nconst diffChildren = ({ oldParentVNode, oldDom, newParentVNode, renderResult, parentDom, excessDomChildren, commitQueue, }) => {\n    let i, j, newDom, firstChildDom, filteredOldDom;\n    console.log('diffChildren:renderResult.length', renderResult.length);\n    // 以前の子Vnode\n    const oldChildren = (oldParentVNode &&\n        '_children' in oldParentVNode &&\n        oldParentVNode._children) ||\n        constants_1.EMPTY_ARR;\n    const oldChildrenLength = oldChildren.length;\n    // diffElementNodes から呼ばれたときは oldDOM には EMPTY_OBJ が渡されている\n    // 基本excessDomChildrenが生じてない限りはundefined\n    if (oldDom == constants_1.EMPTY_OBJ) {\n        if (oldChildrenLength && 'type' in oldParentVNode) {\n            filteredOldDom = component_1.getDomSibling(oldParentVNode, 0);\n        }\n        else {\n            filteredOldDom = null;\n        }\n    }\n    // newParentVNodeの_childrenを初期化\n    newParentVNode._children = [];\n    let childVNode, oldVNode;\n    // renderResultの分だけ回す\n    for (i = 0; i < renderResult.length; i++) {\n        // vnodeといいつつまだVNode型ではない ChildのArray\n        childVNode = renderResult[i];\n        if (childVNode == null || typeof childVNode == 'boolean') {\n            // JSXの中に{null}とか{true}を入れてる場合の挙動\n            childVNode = newParentVNode._children[i] = null;\n        }\n        else if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n            // JSXの中に{1}とか{\"1\"}を入れてる場合の挙動\n            childVNode = newParentVNode._children[i] = create_element_1.createVNode(null, childVNode, null, null, childVNode);\n        }\n        else if (Array.isArray(childVNode)) {\n            // child が 配列 の場合\n            // → JSXの中に{[1, <div>hoge</div>]}などを入れてる時\n            // FragmentとしてcreateVnodeする\n            childVNode = newParentVNode._children[i] = create_element_1.createVNode(\n            //@ts-ignore TODO:\n            create_element_1.Fragment, { children: childVNode }, null, null, null);\n        }\n        else if (childVNode._dom != null || childVNode._component != null) {\n            // child が element の場合(一般的なHTMLのエレメント)\n            childVNode = newParentVNode._children[i] = create_element_1.createVNode(childVNode.type, childVNode.props, childVNode.key, null, childVNode._original);\n        }\n        else {\n            // child が コンポーネントの場合\n            childVNode = newParentVNode._children[i] = childVNode;\n        }\n        // Terser removes the `continue` here and wraps the loop body\n        // in a `if (childVNode) { ... } condition\n        if (childVNode == null) {\n            continue;\n        }\n        // 作りだしたVNodeの親が何か記録する\n        childVNode._parent = newParentVNode;\n        childVNode._depth = newParentVNode._depth + 1;\n        // Check if we find a corresponding element in oldChildren.\n        // If found, delete the array item by setting to `undefined`.\n        // We use `undefined`, as `null` is reserved for empty placeholders\n        // (holes).\n        oldVNode = oldChildren[i];\n        // oldVNode = oldChildren[i]がnullなら　新しく作ったchildVNodeと同じkeyのoldChildrenがあったか確認\n        // あったらoldChildrenにundefinedを入れる\n        if (oldVNode === null ||\n            (oldVNode &&\n                childVNode.key == oldVNode.key &&\n                childVNode.type === oldVNode.type)) {\n            oldChildren[i] = undefined;\n        }\n        else {\n            // Either oldVNode === undefined or oldChildrenLength > 0,\n            // so after this loop oldVNode == null or oldVNode is a valid value.\n            // 新しく作ったchildVNodeと同じkeyのoldChildrenがあったか確認\n            // あったらoldChildrenにundefinedを入れる\n            for (j = 0; j < oldChildrenLength; j++) {\n                oldVNode = oldChildren[j];\n                // If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n                // We always match by type (in either case).\n                if (oldVNode &&\n                    childVNode.key == oldVNode.key &&\n                    childVNode.type === oldVNode.type) {\n                    oldChildren[j] = undefined;\n                    break;\n                }\n                oldVNode = null;\n            }\n        }\n        oldVNode = oldVNode || constants_1.EMPTY_OBJ;\n        // Morph the old element into the new one, but don't append it to the dom yet\n        // またdiffを呼びその返り値をnewDomとする\n        newDom = _1.diff({\n            parentDom: parentDom,\n            newVNode: childVNode,\n            oldVNode: oldVNode,\n            excessDomChildren: excessDomChildren,\n            commitQueue: commitQueue,\n            oldDom: filteredOldDom,\n        });\n        // 新しいDOMがあれば挿入する\n        if (newDom != null) {\n            if (firstChildDom == null) {\n                firstChildDom = newDom;\n            }\n            // 子要素を実際に追加\n            // ついでにoldDomを更新する\n            filteredOldDom = placeChild({\n                parentDom: parentDom,\n                childVNode: childVNode,\n                oldVNode: oldVNode,\n                oldChildren: oldChildren,\n                excessDomChildren: excessDomChildren,\n                newDom: newDom,\n                oldDom: filteredOldDom,\n            });\n            if (typeof newParentVNode.type == 'function') {\n                newParentVNode._nextDom = filteredOldDom;\n            }\n        }\n    }\n    // TODO\n    newParentVNode._dom = firstChildDom;\n    // Remove remaining oldChildren if there are any.\n    // oldChildrenにundefinedが入っていないものは全てunmount\n    // for ループの中で使用済みのものには undefined が詰め込まれているはず。\n    // それでも余っているものをここでunmountする\n    for (i = oldChildrenLength; i--;) {\n        if (oldChildren[i] != null)\n            _1.unmount(oldChildren[i], oldChildren[i], undefined);\n    }\n};\nexports.diffChildren = diffChildren;\nfunction placeChild(arg) {\n    let { parentDom, childVNode, oldVNode, oldChildren, excessDomChildren, newDom, oldDom, } = arg;\n    let nextDom;\n    if (childVNode._nextDom !== undefined) {\n        nextDom = childVNode._nextDom;\n        childVNode._nextDom = undefined;\n    }\n    else if (excessDomChildren == oldVNode ||\n        newDom != oldDom ||\n        newDom.parentNode == null) {\n        outer: if (oldDom == null || oldDom.parentNode !== parentDom) {\n            // 親が異なるなら兄弟ではないので子要素を追加\n            parentDom.appendChild(newDom);\n            nextDom = null;\n        }\n        else {\n            // 親が同じなら兄弟要素を追加\n            if (!Array.isArray(oldChildren)) {\n                throw new Error('配列であるべき');\n            }\n            for (let sibDom = oldDom, j = 0; (sibDom = sibDom.nextSibling) && j < oldChildren.length; j += 2) {\n                if (sibDom == newDom) {\n                    break outer;\n                }\n            }\n            parentDom.insertBefore(newDom, oldDom);\n            nextDom = oldDom;\n        }\n    }\n    if (nextDom !== undefined) {\n        oldDom = nextDom;\n    }\n    else {\n        oldDom = newDom.nextSibling;\n    }\n    return oldDom;\n}\nexports.placeChild = placeChild;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/diff/children.js?");

/***/ }),

/***/ "../sajiact/dist/diff/index.js":
/*!*************************************!*\
  !*** ../sajiact/dist/diff/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unmount = exports.commitRoot = exports.diff = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ \"../sajiact/dist/constants.js\");\nconst create_element_1 = __webpack_require__(/*! ../create-element */ \"../sajiact/dist/create-element.js\");\nconst props_1 = __webpack_require__(/*! ./props */ \"../sajiact/dist/diff/props.js\");\nconst children_1 = __webpack_require__(/*! ./children */ \"../sajiact/dist/diff/children.js\");\nconst component_1 = __webpack_require__(/*! ../component */ \"../sajiact/dist/component.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../sajiact/dist/util.js\");\nconst diff = ({ newVNode, oldVNode, commitQueue, parentDom, excessDomChildren, oldDom, }) => {\n    // 変更したいVnodeのtype(stringまたはclass/functionComponent)\n    const newVNodeType = newVNode.type;\n    console.log('diff:newVNodeType', newVNodeType);\n    // When passing through createElement it assigns the object\n    // constructor as undefined. This to prevent JSON-injection.\n    if (newVNode.constructor !== undefined)\n        return null;\n    try {\n        // 変更したいVnodeのtypeにfunctionが指定されている = functional/class両方\n        // ルートは基本Fragment\n        if (typeof newVNodeType === 'function') {\n            // 新しいProps\n            const newProps = newVNode.props;\n            //\n            let newComponent, isNew, oldProps;\n            // diffをとるのがcomponentの時\n            // すでに以前のcomponentがある時 = setStateの時とか\n            if ('_component' in oldVNode && oldVNode._component) {\n                // component自体は変わらない\n                newComponent = newVNode._component = oldVNode._component;\n            }\n            else {\n                // 新しくComponentを作成する必要がある時\n                if ('prototype' in newVNodeType && newVNodeType.prototype.render) {\n                    // classComponentの場合\n                    // newVnodeTpyeに指定されたClassをnewして新しいComponentとする\n                    // @ts-ignore\n                    newVNode._component = newComponent = new newVNodeType(newProps);\n                }\n                else {\n                    // functiocalComponentの場合\n                    // Component funtionをnewする\n                    //@ts-ignore TODO:\n                    newVNode._component = newComponent = new component_1.Component(newProps);\n                    // コンストラクタの作成\n                    newComponent.constructor = newVNodeType;\n                    // renderの作成\n                    newComponent.render = doRender;\n                }\n                // 新しいComponentの初期化\n                newComponent.props = newProps;\n                // TODO: state入ることあるのか\n                if (!newComponent.state)\n                    newComponent.state = {};\n                // あたしくcomponentを作成したので isNewフラグをtrue\n                isNew = newComponent._dirty = true;\n                //\n                newComponent._renderCallbacks = [];\n            }\n            // stateを利用するための_newxtStateの初期化\n            if (newComponent._nextState == null) {\n                newComponent._nextState = newComponent.state;\n            }\n            // 記憶しておく\n            oldProps = newComponent.props;\n            // ライフサイクル\n            // shouldComponentUpdate ,componentWillUpdate,componentDidUpdate,componentWillMountは削った\n            // 新しくComponentを作成した時\n            if (isNew) {\n                // componentDidMountをrenderCallbacksに登録しておく\n                if (newComponent.componentDidMount != null) {\n                    newComponent._renderCallbacks.push(newComponent.componentDidMount);\n                }\n            }\n            else {\n                // 新しくComponentが生成されてない場合\n                if (\n                // getDerivedStateFromPropsがある場合はcomponentWillReceivePropsが走る前にreRenderされる可能性あり\n                newVNodeType.getDerivedStateFromProps === null &&\n                    // Propsが違う時のみcomponentWillReceivePropsを行う\n                    newProps !== oldProps &&\n                    // componentWillReceivePropsが設定されてたら\n                    newComponent.componentWillReceiveProps != null) {\n                    newComponent.componentWillReceiveProps(newProps);\n                }\n            }\n            // 新しいComponentのpropsとstateを設定\n            newComponent.props = newProps;\n            newComponent.state = newComponent._nextState;\n            // _dirtyをfalseにする\n            newComponent._dirty = false;\n            // 新しいComponentのVnodeを設定\n            newComponent._vnode = newVNode;\n            // 新しいComponentのparentDomを設定\n            newComponent._parentDom = parentDom;\n            // render結果を一時的にもつ\n            const newComponentRenderResultTmp = newComponent.render(newComponent.props);\n            // Handle setState called in render, see #2553　(TODO: なんでもう一回呼ぶのか調べる)\n            newComponent.state = newComponent._nextState;\n            // 新しいコンポーネントのrender結果がフラグメントの場合かどうか\n            const isTopLevelFragment = newComponentRenderResultTmp != null &&\n                newComponentRenderResultTmp.type == create_element_1.Fragment &&\n                newComponentRenderResultTmp.key == null;\n            // 新しいコンポーネントのrender結果がフラグメントだったらそのChildrenを返すようにする\n            const newComponentRenderResult = isTopLevelFragment\n                ? newComponentRenderResultTmp.props.children\n                : newComponentRenderResultTmp;\n            console.log('diff:newComponent', newComponent);\n            //\n            children_1.diffChildren({\n                parentDom: parentDom,\n                // renderを呼び出した結果をrenderResultにいれる\n                renderResult: Array.isArray(newComponentRenderResult)\n                    ? newComponentRenderResult\n                    : [newComponentRenderResult],\n                newParentVNode: newVNode,\n                oldParentVNode: oldVNode,\n                excessDomChildren: excessDomChildren,\n                commitQueue: commitQueue,\n                oldDom: oldDom,\n            });\n            //\n            newComponent.base = newVNode._dom;\n            // componentDidMountなどが入っていれば\n            if (newComponent._renderCallbacks.length) {\n                // commitQueueに追加\n                commitQueue.push(newComponent);\n            }\n            // TODO\n            newComponent._force = false;\n            //これ以降は diffの対象がコンポーネントでない = diff を取る対象が primitive=最後はこの分岐に入る\n        }\n        else if (\n        // excessDomChildrenが存在しなくかつnewVnodeとoldVnodeのオリジナルが一致\n        excessDomChildren == null &&\n            '_component' in oldVNode &&\n            newVNode._original === oldVNode._original) {\n            // 基本この分岐に入ることはない\n            newVNode._children = oldVNode._children;\n            newVNode._dom = oldVNode._dom;\n        }\n        else {\n            console.log('diff:primitive');\n            // primitiveの場合\n            newVNode._dom = diffElementNodes({\n                dom: '_dom' in oldVNode ? oldVNode._dom : null,\n                newVNode: newVNode,\n                oldVNode: oldVNode,\n                excessDomChildren: excessDomChildren,\n                commitQueue: commitQueue,\n            });\n        }\n        // newVnodeのdomを返す\n        return newVNode._dom;\n    }\n    catch (error) {\n        console.error(error);\n    }\n};\nexports.diff = diff;\nconst commitRoot = (commitQueue) => {\n    commitQueue.some((c) => {\n        // @ts-ignore Reuse the commitQueue variable here so the type changes\n        commitQueue = c._renderCallbacks;\n        // @ts-ignore Reuse the commitQueue variable here so the type changes\n        c._renderCallbacks = [];\n        commitQueue.some((cb) => {\n            // @ts-ignore See above ts-ignore on commitQueue\n            cb.call(c);\n        });\n    });\n};\nexports.commitRoot = commitRoot;\nconst diffElementNodes = ({ oldVNode, newVNode, dom, excessDomChildren, commitQueue, }) => {\n    const oldProps = 'props' in oldVNode ? oldVNode.props : constants_1.EMPTY_OBJ;\n    const newProps = newVNode.props;\n    const newVNodeType = newVNode.type;\n    console.log('diffElementNodes:dom', dom);\n    // dom(diffでoldVnodeの_domとして渡される)がない\n    if (dom == null) {\n        // 新しいVNodeのタイプが不明 = テキストとして解釈するしかない\n        if (newVNodeType === null) {\n            //最終的に再起はここで終わる\n            // @ts-ignore createTextNode returns Text, we expect PreactElement\n            return document.createTextNode(newProps);\n        }\n        // @ts-ignore _listenerがないと怒られる\n        // ここでcreateElementしている\n        dom = document.createElement(\n        // @ts-ignore We know `newVNode.type` is a string\n        newVNodeType, newProps.is && newProps);\n        // TODO\n        excessDomChildren = null;\n    }\n    console.log('diffElementNodes:newVNodeType', newVNodeType);\n    // newVNode 不明　= textとして扱う\n    if (newVNodeType === null) {\n        // TODO 型が....\n        const textNodeProps = newProps;\n        if (oldProps !== newProps && dom.data !== textNodeProps) {\n            // propsが変更されていたらdataにpropsのデータを入れる\n            dom.data = textNodeProps;\n        }\n        // newVNode が 何らかのプリミティブな element の場合\n    }\n    else {\n        // props\n        const props = oldProps;\n        // VNodeのpropsの差分を取り、domを破壊的に変更\n        props_1.diffProps(dom, newProps, props);\n        // VNode の children に diff を取るためにchildrenを抽出\n        const propsChildren = newVNode.props.children;\n        // newVNodeがComponentの入れ子でなくてもプリミティブなElementの入れ子の可能性があるので、childrenの比較も行う\n        children_1.diffChildren({\n            // この先はchildrenの比較なので\n            parentDom: dom,\n            // childrenを入れる\n            renderResult: Array.isArray(propsChildren)\n                ? propsChildren\n                : [propsChildren],\n            newParentVNode: newVNode,\n            oldParentVNode: oldVNode,\n            excessDomChildren: excessDomChildren,\n            commitQueue: commitQueue,\n            // oldDomはなし？\n            oldDom: constants_1.EMPTY_OBJ,\n        });\n    }\n    return dom;\n};\n/**\n * componentWillUnmount の実行と、DOMツリーからNodeをremoveする\n * @param vnode\n * @param parentVNode\n * @param skipRemove\n */\nfunction unmount(vnode, parentVNode, skipRemove) {\n    let r;\n    let dom;\n    if (!skipRemove && typeof vnode.type != 'function') {\n        skipRemove = (dom = vnode._dom) != null;\n    }\n    // Must be set to `undefined` to properly clean up `_nextDom`\n    // for which `null` is a valid value. See comment in `create-element.js`\n    vnode._dom = vnode._nextDom = undefined;\n    if ((r = vnode._component) != null) {\n        if (r.componentWillUnmount) {\n            r.componentWillUnmount();\n        }\n        r.base = r._parentDom = null;\n    }\n    if ((r = vnode._children)) {\n        for (let i = 0; i < r.length; i++) {\n            if (r[i])\n                unmount(r[i], parentVNode, skipRemove);\n        }\n    }\n    if (dom != null)\n        util_1.removeNode(dom);\n}\nexports.unmount = unmount;\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props) {\n    return this.constructor(props);\n}\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/diff/index.js?");

/***/ }),

/***/ "../sajiact/dist/diff/props.js":
/*!*************************************!*\
  !*** ../sajiact/dist/diff/props.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setProperty = exports.diffProps = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ \"../sajiact/dist/constants.js\");\nconst diffProps = (dom, newProps, oldProps) => {\n    let propsKey;\n    for (propsKey in oldProps) {\n        if (propsKey !== 'children' &&\n            propsKey !== 'key' &&\n            !(propsKey in newProps)) {\n            // 新しいpropsでkeyがなくなっている場合 newValueはnullに\n            exports.setProperty(dom, propsKey, null, oldProps[propsKey]);\n        }\n    }\n    for (propsKey in newProps) {\n        if (propsKey !== 'children' &&\n            propsKey !== 'key' &&\n            propsKey !== 'value' &&\n            propsKey !== 'checked' &&\n            oldProps[propsKey] !== newProps[propsKey]) {\n            // 新しいPropsが過去のPropsと異なる場合\n            exports.setProperty(dom, propsKey, newProps[propsKey], oldProps[propsKey]);\n        }\n    }\n};\nexports.diffProps = diffProps;\nconst setStyle = (style, key, value) => {\n    if (key[0] === '-') {\n        style.setProperty(key, value);\n    }\n    else if (value == null) {\n        style[key] = '';\n    }\n    else if (typeof value != 'number' || constants_1.IS_NON_DIMENSIONAL.test(key)) {\n        style[key] = value;\n    }\n    else {\n        style[key] = value + 'px';\n    }\n};\nconst setProperty = (dom, //TODO 型合わない\nname, newValue, oldValue) => {\n    // style属性の書き換え(Textは無理っぽいので除外)\n    if (name === 'style' && 'style' in dom) {\n        if (typeof newValue == 'string') {\n            dom.style.cssText = newValue;\n        }\n        else {\n            if (typeof oldValue == 'string') {\n                dom.style.cssText = oldValue = '';\n            }\n            if (oldValue) {\n                for (name in oldValue) {\n                    if (!(newValue && name in newValue)) {\n                        setStyle(dom.style, name, '');\n                    }\n                }\n            }\n            if (newValue) {\n                for (name in newValue) {\n                    if (!oldValue || newValue[name] !== oldValue[name]) {\n                        setStyle(dom.style, name, newValue[name]);\n                    }\n                }\n            }\n        }\n    }\n    else if (name[0] === 'o' && name[1] === 'n') {\n        //onHoge系のイベントハンドラの場合\n        //\n        const useCapture = name !== (name = name.replace(/Capture$/, ''));\n        // Infer correct casing for DOM built-in events:\n        // 小文字化してdomの型にある既存のやつだったら小文字化したままonだけ削る\n        if (name.toLowerCase() in dom)\n            name = name.toLowerCase().slice(2);\n        // そうじゃなくてもonだけ削る\n        else\n            name = name.slice(2);\n        // _listenersいなかったら作る\n        if (!dom._listeners)\n            dom._listeners = {};\n        dom._listeners[name + useCapture] = newValue;\n        if (newValue) {\n            if (!oldValue) {\n                const handler = useCapture ? eventProxyCapture : eventProxy;\n                dom.addEventListener(name, handler, useCapture);\n            }\n        }\n        else {\n            const handler = useCapture ? eventProxyCapture : eventProxy;\n            dom.removeEventListener(name, handler, useCapture);\n        }\n    }\n    else if (name !== 'dangerouslySetInnerHTML' && 'setAttribute' in dom) {\n        if (name !== 'href' &&\n            name !== 'list' &&\n            name !== 'form' &&\n            // Default value in browsers is `-1` and an empty string is\n            // cast to `0` instead\n            name !== 'tabIndex' &&\n            name !== 'download' &&\n            name in dom) {\n            dom[name] = newValue == null ? '' : newValue;\n            // labelled break is 1b smaller here than a return statement (sorry)\n        }\n        else if (typeof newValue === 'function') {\n            // never serialize functions as attribute values\n        }\n        else if (newValue != null &&\n            (newValue !== false || (name[0] === 'a' && name[1] === 'r'))) {\n            // ARIA-attributes have a different notion of boolean values.\n            // The value `false` is different from the attribute not\n            // existing on the DOM, so we can't remove it. For non-boolean\n            // ARIA-attributes we could treat false as a removal, but the\n            // amount of exceptions would cost us too many bytes. On top of\n            // that other VDOM frameworks also always stringify `false`.\n            // ariaラベルへの処理\n            dom.setAttribute(name, newValue);\n        }\n        else {\n            dom.removeAttribute(name);\n        }\n    }\n};\nexports.setProperty = setProperty;\nfunction eventProxy(e) {\n    this._listeners[e.type + false](e);\n}\nfunction eventProxyCapture(e) {\n    this._listeners[e.type + true](e);\n}\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/diff/props.js?");

/***/ }),

/***/ "../sajiact/dist/index.js":
/*!********************************!*\
  !*** ../sajiact/dist/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Component = exports.h = exports.createElement = exports.render = void 0;\nvar render_1 = __webpack_require__(/*! ./render */ \"../sajiact/dist/render.js\");\nObject.defineProperty(exports, \"render\", ({ enumerable: true, get: function () { return render_1.render; } }));\nvar create_element_1 = __webpack_require__(/*! ./create-element */ \"../sajiact/dist/create-element.js\");\nObject.defineProperty(exports, \"createElement\", ({ enumerable: true, get: function () { return create_element_1.createElement; } }));\nObject.defineProperty(exports, \"h\", ({ enumerable: true, get: function () { return create_element_1.createElement; } }));\nvar component_1 = __webpack_require__(/*! ./component */ \"../sajiact/dist/component.js\");\nObject.defineProperty(exports, \"Component\", ({ enumerable: true, get: function () { return component_1.Component; } }));\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/index.js?");

/***/ }),

/***/ "../sajiact/dist/render.js":
/*!*********************************!*\
  !*** ../sajiact/dist/render.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.render = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../sajiact/dist/constants.js\");\nconst create_element_1 = __webpack_require__(/*! ./create-element */ \"../sajiact/dist/create-element.js\");\nconst index_1 = __webpack_require__(/*! ./diff/index */ \"../sajiact/dist/diff/index.js\");\nconst render = (vnode, parentDom) => {\n    // parentDomの_childrenがいれば記録する\n    const oldVNode = parentDom._children;\n    console.log('render:oldVNode', oldVNode);\n    // 新しくVNodeを作成\n    //  typeはFragment\n    //  Propsなし\n    //  childrenは渡されたvnode\n    const newVNode = create_element_1.createElement(create_element_1.Fragment, null, [\n        vnode,\n    ]);\n    console.log('render:newVNode', newVNode);\n    // parentDomの._childrenにnewVNodeを入れる\n    parentDom._children = newVNode;\n    console.log('render:parentDom', parentDom);\n    // 実行するライフサイクルイベント管理用\n    const commitQueue = [];\n    // diff関数呼び出し\n    index_1.diff({\n        parentDom: parentDom,\n        newVNode,\n        // 以前のVNode。なければ空オブジェクト\n        oldVNode: oldVNode || constants_1.EMPTY_OBJ,\n        // globalContext: EMPTY_OBJ,\n        // vnodeに記録されてないがchildにいるNodeがあったら\n        excessDomChildren: oldVNode\n            ? null\n            : parentDom.firstChild\n                ? constants_1.EMPTY_ARR.slice.call(parentDom.childNodes)\n                : null,\n        commitQueue,\n        oldDom: oldVNode ? oldVNode._dom : parentDom.firstChild,\n    });\n    console.log('render:commitQueue', commitQueue);\n    // 登録されたエフェクトを読んで消す\n    index_1.commitRoot(commitQueue);\n    console.log('render:commitQueue', commitQueue);\n};\nexports.render = render;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/render.js?");

/***/ }),

/***/ "../sajiact/dist/util.js":
/*!*******************************!*\
  !*** ../sajiact/dist/util.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeNode = exports.assign = void 0;\nfunction assign(obj, props) {\n    for (let i in props)\n        obj[i] = props[i];\n    return /** @type {O & P} */ obj;\n}\nexports.assign = assign;\nfunction removeNode(node) {\n    let parentNode = node.parentNode;\n    if (parentNode)\n        parentNode.removeChild(node);\n}\nexports.removeNode = removeNode;\n\n\n//# sourceURL=webpack://sajiact-example/../sajiact/dist/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;